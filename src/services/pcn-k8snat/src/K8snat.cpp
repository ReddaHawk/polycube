/**
* k8snat API generated from k8snat.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/


// TODO: Modify these methods with your own implementation


#include "K8snat.h"
#include "K8snat_dp.h"

K8snat::K8snat(const std::string name, const K8snatJsonObject &conf)
  : Cube(conf.getBase(), { k8snat_code }, {}),
    K8snatBase(name) {
  logger()->info("Creating K8snat instance");
  addPortsList(conf.getPorts());
  addRule(conf.getRule());
  //addNattingTableList(conf.getNattingTable());
}


K8snat::~K8snat() {
  logger()->info("Destroying K8snat instance");
}

void K8snat::packet_in(Ports &port,
    polycube::service::PacketInMetadata &md,
    const std::vector<uint8_t> &packet) {
  logger()->debug("Packet received from port {0}", port.name());
}

K8snatJsonObject K8snat::toJsonObject() {
  K8snatJsonObject conf;
  conf.setBase(Cube::to_json());
  conf.setRule(getRule()->toJsonObject());
  for(auto &i : getPortsList()){
    conf.addPorts(i->toJsonObject());
  }
  for (auto &i : getNattingTableList()) {
    conf.addNattingTable(i->toJsonObject());
  }
  return conf;

}

void K8snat::reloadConfig() {
  std::string flags;

  // ports
  uint16_t frontend = 0;
  uint16_t backend = 0;
  uint16_t nodeport = 0;
  for (auto &it : get_ports()) {
    switch (it->getType()) {
    case PortsTypeEnum::FRONTEND:
      frontend = it->index();
      break;
    case PortsTypeEnum::BACKEND:
      backend = it->index();
      break;
    case PortsTypeEnum::NODEPORT:
      nodeport = it->index();
      break;
    }
  }

  flags += "#define FRONTEND_PORT " + std::to_string(frontend) + "\n";
  flags += "#define BACKEND_PORT " + std::to_string(backend) + "\n";
  //todo introduce nodeport variable
  //flags += "#define NODEPORT_PORT " + std::to_string(backend) + "\n";

  flags += "#define NODEPORT_RANGE_LOW " + std::to_string(30000) +
           "\n";
  flags += "#define NODEPORT_RANGE_HIGH " +
           std::to_string(32767) + "\n";

  logger()->debug("Reloading code with flags port: {}", flags);

  reload(flags + k8snat_code);

  logger()->trace("New K8sNat code loaded");
}

// Basic default implementation, place your extension here (if needed)
std::shared_ptr<Ports> K8snat::getPorts(const std::string &name) {
  // call default implementation in base class
  return K8snatBase::getPorts(name);
}

// Basic default implementation, place your extension here (if needed)
std::vector<std::shared_ptr<Ports>> K8snat::getPortsList() {
  // call default implementation in base class
  return K8snatBase::getPortsList();
}

// Basic default implementation, place your extension here (if needed)
void K8snat::addPorts(const std::string &name, const PortsJsonObject &conf) {
  // K8snatBase::addPorts(name, conf);
  if (get_ports().size() == 3) {
    logger()->warn("Reached maximum number of ports");
    throw std::runtime_error("Reached maximum number of ports");
  }

  try {
    switch (conf.getType()) {
    case PortsTypeEnum::FRONTEND:
      if (getFrontendPort() != nullptr) {
        logger()->warn("There is already a FRONTEND port");
        throw std::runtime_error("There is already a FRONTEND port");
      }
      break;
    case PortsTypeEnum::BACKEND:
      if (getBackendPort() != nullptr) {
        logger()->warn("There is already a BACKEND port");
        throw std::runtime_error("There is already a BACKEND port");
      }
      break;
    case PortsTypeEnum::NODEPORT:
      if (getFrontendPort() != nullptr) {
        logger()->warn("There is already a NODEPORT port");
        throw std::runtime_error("There is already a FRONTEND port");
      }
      break;
    }

  } catch (std::runtime_error &e) {
    logger()->warn("Error when adding the port {0}", name);
    logger()->warn("Error message: {0}", e.what());
    throw;
  }
  add_port<PortsJsonObject>(name, conf);
  //todo change it to 3 to support nodeport
  if (get_ports().size() ==2) {
    logger()->info("Reloading code because of the new port");
    reloadConfig();
  }

  logger()->info("New port created with name {0}", name);
}

// Basic default implementation, place your extension here (if needed)
void K8snat::addPortsList(const std::vector<PortsJsonObject> &conf) {
  // call default implementation in base class
  //K8snatBase::addPortsList(conf);
  for (auto &i : conf) {
    std::string name_ = i.getName();
    addPorts(name_, i);
  }
}

// Basic default implementation, place your extension here (if needed)
void K8snat::replacePorts(const std::string &name, const PortsJsonObject &conf) {
  // call default implementation in base class
  K8snatBase::replacePorts(name, conf);

}

// Basic default implementation, place your extension here (if needed)
void K8snat::delPorts(const std::string &name) {
  // call default implementation in base class
  K8snatBase::delPorts(name);
}

// Basic default implementation, place your extension here (if needed)
void K8snat::delPortsList() {
  // call default implementation in base class
  K8snatBase::delPortsList();
}

std::shared_ptr<Rule> K8snat::getRule() {
  return rule_;
}

void K8snat::addRule(const RuleJsonObject &value) {
  rule_ = std::make_shared<Rule>(*this, value);
}

// Basic default implementation, place your extension here (if needed)
void K8snat::replaceRule(const RuleJsonObject &conf) {
  // call default implementation in base class
  //K8snatBase::replaceRule(conf);
  delRule();
  addRule(conf);
}

void K8snat::delRule() {
  rule_ = nullptr;
}

uint8_t K8snat::proto_from_string_to_int(const std::string &proto) {
  if (proto == "icmp" || proto == "ICMP") {
    return IPPROTO_ICMP;
  }
  if (proto == "tcp" || proto == "TCP") {
    return IPPROTO_TCP;
  }
  if (proto == "udp" || proto == "UDP") {
    return IPPROTO_UDP;
  }
  return -1;
}

std::shared_ptr<NattingTable> K8snat::getNattingTable(const std::string &internalSrc, const std::string &internalDst, const uint16_t &internalSport, const uint16_t &internalDport, const std::string &proto) {
  try {
    auto table = get_hash_table<st_k, st_v>("egress_session_table");
    st_k map_key{
        .src_ip = polycube::service::utils::ip_string_to_nbo_uint(internalSrc),
        .dst_ip = polycube::service::utils::ip_string_to_nbo_uint(internalDst),
        .src_port = htons(internalSport),
        .dst_port = htons(internalDport),
        .proto = uint8_t(std::stol(proto)),
    };

    st_v value = table.get(map_key);

    std::string newIp = polycube::service::utils::nbo_uint_to_ip_string(value.new_ip);
    uint16_t newPort = value.new_port;
    uint8_t originatingRule = value.originating_rule_type;
    ;
    auto entry = std::make_shared<NattingTable>(
        *this, internalSrc, internalDst, internalSport, internalDport,
        proto_from_string_to_int(proto), newIp, newPort, originatingRule);
    return entry;
  } catch (std::exception &e) {
    throw std::runtime_error("Natting table entry not found");
  }
}

std::vector<std::shared_ptr<NattingTable>> K8snat::getNattingTableList() {
  logger()->debug("getNattingTable");
  std::vector<std::shared_ptr<NattingTable>> entries;
  try {
    auto table = get_hash_table<st_k, st_v>("egress_session_table");
    auto map_entries = table.get_all();
    for (auto &pair : map_entries) {
      auto key = pair.first;
      auto value = pair.second;

      auto entry = std::make_shared<NattingTable>(
          *this, polycube::service::utils::nbo_uint_to_ip_string(key.src_ip),
          polycube::service::utils::nbo_uint_to_ip_string(key.dst_ip), ntohs(key.src_port),
          ntohs(key.dst_port), key.proto,
          polycube::service::utils::nbo_uint_to_ip_string(value.new_ip), ntohs(value.new_port),
          value.originating_rule_type);

      entries.push_back(entry);
    }
  } catch (std::exception &e) {
    throw std::runtime_error("Unable to get the natting table");
  }
  return entries;
}

void K8snat::addNattingTable(const std::string &internalSrc, const std::string &internalDst, const uint16_t &internalSport, const uint16_t &internalDport, const std::string &proto, const NattingTableJsonObject &conf) {
  throw std::runtime_error("Cannot manually create natting table entries");
}

// Basic default implementation, place your extension here (if needed)
void K8snat::addNattingTableList(const std::vector<NattingTableJsonObject> &conf) {
  // call default implementation in base class
  throw std::runtime_error("Cannot manually create natting table entries");
}

// Basic default implementation, place your extension here (if needed)
void K8snat::replaceNattingTable(const std::string &internalSrc, const std::string &internalDst, const uint16_t &internalSport, const uint16_t &internalDport, const std::string &proto, const NattingTableJsonObject &conf) {
  // call default implementation in base class
  throw std::runtime_error("Cannot manually create natting table entries");
}

void K8snat::delNattingTable(const std::string &internalSrc, const std::string &internalDst, const uint16_t &internalSport, const uint16_t &internalDport, const std::string &proto) {
  throw std::runtime_error("Cannot manually remove single natting table entries");
}

// Basic default implementation, place your extension here (if needed)
void K8snat::delNattingTableList() {
  auto egress_table = get_hash_table<st_k, st_v>("egress_session_table");
  egress_table.remove_all();
  auto ingress_table = get_hash_table<st_k, st_v>("ingress_session_table");
  ingress_table.remove_all();

  logger()->info("Flushed natting tables");
}

std::shared_ptr<Ports> K8snat::getFrontendPort() {
  for (auto &it : get_ports()) {
    if (it->getType() == PortsTypeEnum::FRONTEND) {
      return it;
    }
  }
  return nullptr;
}

std::shared_ptr<Ports> K8snat::getBackendPort() {
  for (auto &it : get_ports()) {
    if (it->getType() == PortsTypeEnum::BACKEND) {
      return it;
    }
  }
  return nullptr;
}

std::shared_ptr<Ports> K8snat::getNodeportPort() {
  for (auto &it : get_ports()) {
    if (it->getType() == PortsTypeEnum::NODEPORT) {
      return it;
    }
  }
  return nullptr;
}
std::string K8snat::proto_from_int_to_string(const uint8_t proto) {
  switch (proto) {
  case IPPROTO_ICMP:
    return "icmp";
  case IPPROTO_TCP:
    return "tcp";
  case IPPROTO_UDP:
    return "udp";
  default:
    // Never happens
    return "unknown";
  }
}
const std::string &K8snat::getExternalIpString() {
  return external_ip_;
}
