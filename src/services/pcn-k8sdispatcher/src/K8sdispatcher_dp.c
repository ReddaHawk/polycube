/**
 * k8sdispatcher API generated from k8sdispatcher.yang
 *
 * NOTE: This file is auto generated by polycube-codegen
 * https://github.com/polycube-network/polycube-codegen
 */

/*
 * This function is called each time a packet arrives to the cube.
 * ctx contains the packet and md some additional metadata for the packet.
 * If the service is of type XDP_SKB/DRV CTX TYPE is equivalent to the struct
 * xdp_md otherwise, if the service is of type TC, CTXTYPE is equivalent to
 * the __sk_buff struct
 * Please look at the libpolycube documentation for more details.
 */
#include <linux/jhash.h>
#include <uapi/linux/icmp.h>
#include <uapi/linux/if_arp.h>
#include <uapi/linux/ip.h>
#include <uapi/linux/tcp.h>
#include <uapi/linux/udp.h>
#include <uapi/linux/bpf.h>
#include <uapi/linux/filter.h>
#include <uapi/linux/if_ether.h>
#include <uapi/linux/if_packet.h>
#include <uapi/linux/in.h>
#include <uapi/linux/pkt_cls.h>
#define NAT_MAP_DIM 32768
#define IP_CSUM_OFFSET (sizeof(struct eth_hdr) + offsetof(struct iphdr, check))
#define UDP_CSUM_OFFSET                            \
  (sizeof(struct eth_hdr) + sizeof(struct iphdr) + \
   offsetof(struct udphdr, check))
#define TCP_CSUM_OFFSET                            \
  (sizeof(struct eth_hdr) + sizeof(struct iphdr) + \
   offsetof(struct tcphdr, check))
#define ICMP_CSUM_OFFSET                           \
  (sizeof(struct eth_hdr) + sizeof(struct iphdr) + \
   offsetof(struct icmphdr, checksum))
#define IS_PSEUDO 0x10
#ifndef FRONTEND_PORT
#define FRONTEND_PORT 0
#endif

#ifndef BACKEND_PORT
#define BACKEND_PORT 0
#endif

#ifndef NODEPORT_RANGE_LOW
#define NODEPORT_RANGE_LOW (30000)
#endif

#ifndef NODEPORT_RANGE_HIGH
#define NODEPORT_RANGE_HIGH (32767)
#endif

#ifndef EXTERNAL_IP
#define EXTERNAL_IP 0
#endif

#ifndef EXTERNAL_MAC
#define EXTERNAL_MAC 0
#endif

#define NAT_MAP_DIM 32768

// session table
struct st_k {
  uint32_t src_ip;
  uint32_t dst_ip;
  uint16_t src_port;
  uint16_t dst_port;
  uint8_t proto;
} __attribute__((packed));
struct st_v {
  uint32_t new_ip;
  uint16_t new_port;

  // uint8_t originating_rule_type;
} __attribute__((packed));
struct dp_k {
  u32 mask;
  __be32 external_ip;
  __be16 external_port;
  uint8_t proto;
};
struct dp_v {
  __be32 internal_ip;
  __be16 internal_port;
  // uint8_t entry_type;
};
// only needed in egress
// SNAT + MASQUERADE rules
struct sm_k {
  u32 internal_netmask_len;
  __be32 internal_ip;
};
struct sm_v {
  __be32 external_ip;
  uint8_t entry_type;
};
BPF_F_TABLE("lpm_trie", struct sm_k, struct sm_v, sm_rules, 1024,
            BPF_F_NO_PREALLOC);

BPF_F_TABLE("lpm_trie", struct dp_k, struct dp_v, dp_rules, 1024,
            BPF_F_NO_PREALLOC);

BPF_TABLE("lru_hash", struct st_k, struct st_v, egress_session_table,
          NAT_MAP_DIM);
BPF_TABLE("lru_hash", struct st_k, struct st_v, ingress_session_table,
          NAT_MAP_DIM);

struct eth_hdr {
  __be64 dst : 48;
  __be64 src : 48;
  __be16 proto;
} __attribute__((packed));

// Session table

// Port numbers
BPF_TABLE("array", u32, u16, first_free_port, 1);

static inline __be16 get_free_port() {
  u32 i = 0;
  u16 *new_port_p = first_free_port.lookup(&i);
  if (!new_port_p)
    return 0;
  rcu_read_lock();
  if (*new_port_p < 1024 || *new_port_p == 65535)
    *new_port_p = 1024;
  *new_port_p = *new_port_p + 1;
  rcu_read_unlock();
  return bpf_htons(*new_port_p);
}

static __always_inline int handle_rx(struct CTXTYPE *ctx,
                                     struct pkt_metadata *md) {
  pcn_log(ctx, LOG_TRACE, "k8s received packet");

  void *data = (void *)(long)ctx->data;
  void *data_end = (void *)(long)ctx->data_end;

  struct eth_hdr *eth = data;
  if ((void *)eth + sizeof(*eth) > data_end)
    goto DROP;
  pcn_log(
      ctx, LOG_TRACE,
      "Received new packet: in_port: %d eth_type: 0x%x mac_src: %M mac_dst: %M",
      md->in_port, bpf_ntohs(eth->proto), eth->src, eth->dst);

  switch (eth->proto) {
  case htons(ETH_P_IP):
    // Packet is IP
    pcn_log(ctx, LOG_DEBUG, "Received IP Packet");
    break;
  case htons(ETH_P_ARP):
    // Packet is ARP: let is pass
    pcn_log(ctx, LOG_TRACE, "Received ARP packet. Letting it go through");
    return RX_OK;
  default:
    pcn_log(ctx, LOG_TRACE, "Unknown eth proto: %d, dropping",
            bpf_ntohs(eth->proto));
    // todo drop?
    goto DROP;
  }
  pcn_log(ctx, LOG_DEBUG, "MAC src: %M, MAC dst: %M", eth->src, eth->dst);
  // Packet data
  uint32_t srcIp = 0;
  uint32_t dstIp = 0;
  uint16_t srcPort = 0;
  uint16_t dstPort = 0;
  uint8_t proto = 0;

  // Nat data
  uint32_t newIp = 0;
  uint16_t newPort = 0;
  uint8_t rule_type = 0;

  // Status data
  uint8_t update_session_table = 1;

  struct iphdr *ip = data + sizeof(*eth);
  if ((void *)ip + sizeof(*ip) > data_end)
    goto DROP;

  pcn_log(ctx, LOG_DEBUG,
          "Processing IP packet: src %I, dst: %I, external_ip: %I, "
          "external_MAC: %M",
          ip->saddr, ip->daddr, EXTERNAL_IP, EXTERNAL_MAC);

  // check if ip dest is for this host
  if (ip->daddr != EXTERNAL_IP) {
    pcn_log(ctx, LOG_DEBUG, "Packet is not for host, send to stack");
    return RX_OK;
  }
  pcn_log(ctx, LOG_DEBUG,
          "------> Is for host Processing IP packet: src %I, dst: %I, "
          "external_ip: %I, external_MAC: %d",
          ip->saddr, ip->daddr, EXTERNAL_IP, EXTERNAL_MAC);
  srcIp = ip->saddr;
  dstIp = ip->daddr;
  proto = ip->protocol;

  switch (ip->protocol) {
  case IPPROTO_TCP: {
    uint8_t header_len = 4 * ip->ihl;
    struct tcphdr *tcp = data + sizeof(*eth) + header_len;
    if ((void *)tcp + sizeof(*tcp) > data_end)
      goto DROP;

    pcn_log(ctx, LOG_TRACE, "Packet is TCP: src_port %P, dst_port %P",
            tcp->source, tcp->dest);
    srcPort = tcp->source;
    dstPort = tcp->dest;
    break;
  }
  case IPPROTO_UDP: {
    uint8_t header_len = 4 * ip->ihl;
    struct udphdr *udp = data + sizeof(*eth) + header_len;
    if ((void *)udp + sizeof(*udp) > data_end)
      goto DROP;
    pcn_log(ctx, LOG_TRACE, "Packet is UDP: src_port %P, dst_port %P",
            udp->source, udp->dest);
    srcPort = udp->source;
    dstPort = udp->dest;
    break;
  }
  case IPPROTO_ICMP: {
    uint8_t header_len = 4 * ip->ihl;
    struct icmphdr *icmp = data + sizeof(*eth) + header_len;
    if ((void *)icmp + sizeof(*icmp) > data_end)
      goto DROP;
    pcn_log(ctx, LOG_TRACE, "Packet is ICMP: type %d, id %d", icmp->type,
            icmp->un.echo.id);
    if (md->in_port == FRONTEND_PORT)
      return RX_OK;
    // Consider the ICMP ID as a "port" number for easier handling
    srcPort = icmp->un.echo.id;
    dstPort = icmp->un.echo.id;
    break;
  }
  default:
    pcn_log(ctx, LOG_TRACE, "Unknown L4 proto %d, dropping", ip->protocol);
    goto DROP;
  }
  // Packet parsed, start session table lookup
  struct st_k key = {0, 0, 0, 0, 0};
  key.src_ip = srcIp;
  key.dst_ip = dstIp;
  key.src_port = srcPort;
  key.dst_port = dstPort;
  key.proto = proto;
  struct st_v *value;

  if (md->in_port == FRONTEND_PORT) {
    pcn_log(ctx, LOG_DEBUG, "Packet is coming from FRONTEND_PORT");
    // Packet is outside -> inside, check ingress session table
    value = ingress_session_table.lookup(&key);
    if (value != NULL) {
      // Session table hit
      pcn_log(ctx, LOG_TRACE, "Ingress session table: hit");

      newIp = value->new_ip;
      newPort = value->new_port;
      // rule_type = NAT_DST;

      update_session_table = 0;

      goto apply_nat;
    }
    pcn_log(ctx, LOG_TRACE, "Ingress session table: miss");
  } else {
    pcn_log(ctx, LOG_INFO,
            "------>Internal packet Processing IP packet: src %I, dst: %I, "
            "external_ip: %I, external_MAC: %d",
            ip->saddr, ip->daddr, EXTERNAL_IP, EXTERNAL_MAC);
    pcn_log(ctx, LOG_IN, "Ingress session table: miss");
    // Packet is inside -> outside, check egress session table
    value = egress_session_table.lookup(&key);
    if (value != NULL) {
      // Session table hit
      pcn_log(ctx, LOG_TRACE, "Egress session table: hit");

      newIp = value->new_ip;
      newPort = value->new_port;
      // rule_type = NAT_SRC;

      update_session_table = 0;

      goto apply_nat;
    }
    pcn_log(ctx, LOG_TRACE, "Egress session table: miss");
  }
  // Session table miss
  if (md->in_port == BACKEND_PORT) {
    // Packet is inside -> outside, check SNAT/MASQUERADE rule table
    newIp = EXTERNAL_IP;
    newPort = get_free_port();
    goto apply_nat;
  } else {
    // Packet is outside -> inside, check DNAT/PORTFORWARDING rule table
    struct dp_k key = {0, 0, 0};
    key.mask = 56;  // 32 (IP) + 16 (Port) + 8 (Proto)
    key.external_ip = dstIp;
    key.external_port = dstPort;
    key.proto = proto;
    struct dp_v *value = dp_rules.lookup(&key);
    if (value != NULL) {
      pcn_log(ctx, LOG_TRACE, "Ingress rule table: hit");

      newIp = value->internal_ip;
      newPort = value->internal_port;
      // rule_type = value->entry_type;
      /*
      if (newPort == 0) {
        // Matching rule is DNAT, keep the same port number
        newPort = dstPort;
      }
    */
      goto apply_nat;
    }
    pcn_log(ctx, LOG_TRACE, "Ingress rule table: miss");
  }
  goto proceed;

apply_nat:;
  if (update_session_table == 1) {
    // No session table exist for the packet, but a rule matched
    // -> Update the session tables in both directions

    struct st_k forward_key = {0, 0, 0, 0, 0};
    struct st_v forward_value = {0, 0};

    struct st_k reverse_key = {0, 0, 0, 0, 0};
    struct st_v reverse_value = {0, 0};

    // A rule matched in the inside -> outside direction

    // Session table entry for the outgoing packets
    forward_key.src_ip = srcIp;
    forward_key.dst_ip = dstIp;
    forward_key.src_port = srcPort;
    forward_key.dst_port = dstPort;
    forward_key.proto = proto;

    forward_value.new_ip = newIp;
    forward_value.new_port = newPort;
    // forward_value.originating_rule_type = rule_type;

    // Session table entry for the incoming packets
    reverse_key.src_ip = dstIp;
    reverse_key.dst_ip = newIp;
    if (proto == IPPROTO_ICMP) {
      // For ICMP session table entries "source port" and "destination port"
      // must be the same, equal to the ICMP ID
      reverse_key.src_port = newPort;
    } else {
      reverse_key.src_port = dstPort;
    }
    reverse_key.dst_port = newPort;
    reverse_key.proto = proto;

    reverse_value.new_ip = srcIp;
    reverse_value.new_port = srcPort;
    // reverse_value.originating_rule_type = rule_type;

    pcn_log(ctx, LOG_TRACE, "Updating session tables after SNAT");
    pcn_log(ctx, LOG_DEBUG, "New outgoing connection: %I:%P -> %I:%P", srcIp,
            srcPort, dstIp, dstPort);
    egress_session_table.update(&forward_key, &forward_value);
    ingress_session_table.update(&reverse_key, &reverse_value);

    pcn_log(ctx, LOG_TRACE,
            "Using ingress key: srcIp %I, dstIp %I, srcPort %P, dstPort %P",
            reverse_key.src_ip, reverse_key.dst_ip, reverse_key.src_port,
            reverse_key.dst_port);
    pcn_log(ctx, LOG_TRACE,
            "Using egress key: srcIp %I, dstIp %I, srcPort %P, dstPort %P",
            forward_key.src_ip, forward_key.dst_ip, forward_key.src_port,
            forward_key.dst_port);
  }

  // Modify packet
  uint32_t old_ip = srcIp;
  uint32_t old_port = srcPort;
  uint32_t new_ip = newIp;
  uint32_t new_port = newPort;
  uint32_t l3sum = pcn_csum_diff(&old_ip, 4, &new_ip, 4, 0);
  uint32_t l4sum = pcn_csum_diff(&old_port, 4, &new_port, 4, 0);
  switch (proto) {
  case IPPROTO_TCP: {
    uint8_t header_len = 4 * ip->ihl;
    struct tcphdr *tcp = data + sizeof(*eth) + header_len;
    if ((void *)tcp + sizeof(*tcp) > data_end)
      goto DROP;

    ip->saddr = new_ip;
    tcp->source = (__be16)new_port;
    pcn_log(ctx, LOG_TRACE, "Natted TCP packet: source, %I:%P -> %I:%P", old_ip,
            old_port, new_ip, new_port);

    // Update checksums
    pcn_l4_csum_replace(ctx, TCP_CSUM_OFFSET, 0, l3sum, IS_PSEUDO | 0);
    pcn_l4_csum_replace(ctx, TCP_CSUM_OFFSET, 0, l4sum, 0);
    pcn_l3_csum_replace(ctx, IP_CSUM_OFFSET, 0, l3sum, 0);

    goto proceed;
  }
  case IPPROTO_UDP: {
    uint8_t header_len = 4 * ip->ihl;
    struct udphdr *udp = data + sizeof(*eth) + header_len;
    if ((void *)udp + sizeof(*udp) > data_end)
      goto DROP;

    ip->saddr = new_ip;
    udp->source = (__be16)new_port;
    pcn_log(ctx, LOG_TRACE, "Natted UDP packet: source, %I:%P -> %I:%P", old_ip,
            old_port, new_ip, new_port);

    // Update checksums
    pcn_l4_csum_replace(ctx, UDP_CSUM_OFFSET, 0, l3sum, IS_PSEUDO | 0);
    pcn_l4_csum_replace(ctx, UDP_CSUM_OFFSET, 0, l4sum, 0);
    pcn_l3_csum_replace(ctx, IP_CSUM_OFFSET, 0, l3sum, 0);

    goto proceed;
  }
  case IPPROTO_ICMP: {
    uint8_t header_len = 4 * ip->ihl;
    struct icmphdr *icmp = data + sizeof(*eth) + header_len;
    if ((void *)icmp + sizeof(*icmp) > data_end)
      goto DROP;
    ip->saddr = new_ip;
    icmp->un.echo.id = (__be16)new_port;
    pcn_log(ctx, LOG_TRACE, "Natted ICMP packet: source, %I:%P -> %I:%P",
            old_ip, old_port, new_ip, new_port);
    ip->daddr = new_ip;
    icmp->un.echo.id = (__be16)new_port;
    pcn_log(ctx, LOG_TRACE, "Natted ICMP packet: destination, %I:%P -> %I:%P",
            old_ip, old_port, new_ip, new_port);

    // Update checksums
    pcn_l4_csum_replace(ctx, ICMP_CSUM_OFFSET, 0, l4sum, 0);
    pcn_l3_csum_replace(ctx, IP_CSUM_OFFSET, 0, l3sum, 0);

    goto proceed;
  }
  }
proceed:;
  return RX_OK;

DROP:;
  return RX_OK;
}